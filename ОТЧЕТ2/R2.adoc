= Отчет №2

:imagesdir: R2IM

---


== Контрольные вопросы

---

* *Что такое POD типы данных?*

POD - (Plain Old Data) это то есть класс (независимо от того, задано ли оно с ключевым словом struct или ключевым словом class) без смещений, конструкторов, деструкторов и прочего колдунства.
---

* *Назовите все виды типов в языке С++*

*простые:*

целые (bool, char, int, enim, long, short, long long)

с плавающей точкой (float, double, long double)

*структурированные* (array, union, class/structure)

*адресные* (pointer, reference)

---

* *Что такое пользовательский тип?*

Вы можете определить свой тип сами, либо сделать псевдоним типа. Любой класс или структура, определенная вами, будет являться вашим типом. Пользовательский тип делается вручную и может иметь любой псевдоним.

---

* *Назовите модификаторы типов.*

|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

---

* *Назовите правило установки размеров типов*

В различных микроконтроллерах размеры типов могут отличаться. В связи с этим имеет смысл использовать псевдонимы.

----
1             <= sizeof(char)     <= sizeof() <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

---

* *Что делает оператор sizeof()?*

Данный унарный оператор используют для вычисления и возвращает размер определённой переменной или определённого типа данных в байтах.

---

* *Что характеризует тип std::size_t*

std::size_t – целочисленный беззнаковый тип результата, возвращаемого операторами sizeof. Может хранить максимальный размер теоретически возможного объекта любого типа (включая массивы). С++ определяет size_t в пространстве имен std.

---

* *Назовите фиксированные типы целых в библиотеке std*

|=================
|Название|Тип|Диапазон значений
|int8_t|1 байт signed|от -128 до 127
|uint8_t|1 байт unsigned|от 0 до 255
|int16_t|2 байта signed|от -32 768 до 32 767
|uint16_t|2 байта unsigned|от 0 до 65 535
|int32_t|4 байта signed|от -2 147 483 648 до 2 147 483 647
|uint32_t|4 байта unsigned|от 0 до 4 294 967 295
|int64_t|8 байт signed|от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
|uint64_t|8 байт unsigned|от 0 до 18 446 744 073 709 551 615
|=================

---

* *Что такое псевдоним типа?*

Псевдоним типа является именем, ссылающимся на ранее определённый тип, используется для повышения удобства обращения к пользовательским и встроенным типам данных.

---

* *Что такое явное и неявное преобразование типа?*

Неявное преобразование типов данных выполняет компилятор С++, (int a = 3.14;) а явное преобразование данных выполняет сам программист (int a = static_cast<int>(3.14);).

---

* *Какие явные преобразования типов вы знаете?*

static_cast

const_cast

reinterpret_cast

dynamic_cast

---

* *Что делает reinterpret_cast?*

reinterpret_cast преобразует типы, несовместимыми друг с другом, и используется для преобразования:

В свой собственный тип

Указателя в интегральный тип

Интегрального типа в указатель

Указателя одного типа в указатель другого типа

Указателя на функцию одного типа в указатель на функцию другого типа

---

* *Чем static_cast отличается от reinterpret_cast?*

static_cast преобразует выражения одного статического типа в объекты и значения другого статического типа. Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки. Используется для близких типов.

reinterpret_cast — приведение типов без проверки, непосредственное указание компилятору. Применяется только в случае полной уверенности программиста в собственных действиях. Используется для несовместимых типов.

---

* *Что такое ОЗУ и ПЗУ?*

ОЗУ - опертивное запоминающее устройство (RAM).Служит для хранения программ начальной загрузки компьютера и тестирования его узлов. Используется только для чтения. Записанная в ней информация не изменяется после выключения компьютера.

ПЗУ - постоянное запоминающее устройство (ROM). Предназначена для хранения информации, изменяющейся в ходе выполнения процессором операций по ее обработке. Используется как для чтения, так и для записи информации. Вся информация хранится в этой памяти только тогда, когда компьютер включен.

---

* *Каков размер памяти ARM Cortex микроконтроллеров.*

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF.
512 кБайт памяти программ
128 кБайт ОЗУ

---

* *По какой архитектуре разработан ARM Cortex микроконтроллер?*

Микроконтроллер на ядре Cortex M3 выполнен по Гарвардской архитектуре

---

* *В чем отличие Гарвардской архитектуры от Архитектура ФонНеймана?*

.Примеры архитектур
image::Figure1.png[]

Архитектура Фон Неймана. Эта архитектура состоит из единого блока памяти, в котором хранятся и команды, и данные, и общей шины для передачи данных и команд в ЦПУ и от него. При такой архитектуре перемножение двухчисел требует по меньшей мере трех циклов: двух циклов для передачи двух чисел в ЦПУ, и одного – для передачи команды. Данная архитектура приемлема в том случае, когда все действия могут выполняться последовательно.

Гарвардская архитектура. Данные и код программы хранятся в различных блоках памяти и доступ к ним осуществляется через разные шины, как показано на схеме. Т.к. шины работают независимо, выбор команд программы и данных может осуществляться одновременно, повышая таким образом скорость по сравнению со случаем и спользования одной шины вархитектуре Фон Неймана.

Модифицированная гарвардская архитектура. Команды и данные могут храниться в памяти программ. Доступ к памяти осуществляется по одной шине, а уже устройство управления памятью обеспечивает разделение шин при помощи управляющих сигналов: чтения, записи или выбора области памяти. Данные и код могут находится в одной и той же области памяти. В этом едином адресном пространстве может находится и ПЗУ и ОЗУ и периферия. А это означает, что собственно и код и данные могут попасть хоть куда(в ОЗУ или в ПЗУ) и это зависит только от компилятора и линкера.

---

* *Где располагаются локальные переменные?*

Локальные переменные функции создаются на стеке или в регистрах.

---

* *Где располагаются статические переменные?*

инициализируемые - .data
инициализируемые нулем - .bss
данные переменные не изменяются до конца работы приложения.

---

* *Где располагаются глобальные переменные?*

инициализируемые - .data

инициализируемые нулем - .bss

---

* *Что такое стек?*

Стек (англ. Stack - стопкаъ) - абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).

В стек можно положить данные, и можно данные забрать, причем те данные которые были положены в стек последним, забираем из стека первым.

Стек – это организация памяти, выполненная компоновщиком. На уровне микроконтроллера для работы со стеком есть специальные ассемблерные команды (например PUSH – положить регистры в стек, и POP – взять из стека). Так же для сохранения и считывания данных из стека могут использоваться инструкции STR и LDR.

---

* *Что такое указатель?*

Указатель это переменная, которая хранит адрес какой-то другой переменной.

---

* *Что такое разыменовывание указателя?*

Операция, нужная для того, чтобы получить значение, записанное в некоторой области, на которое ссылается указатель

---

* *Что означает взятие адреса?*

Оператор *&* - оператор взятия адреса.

&  перед переменной передает адрес по которому лежат значения этой переменной.

---

* *Какие операции можно выполнять над указателями?*

Указатели можно складывать+, вычитать -, увеличивать ++, сравнивать !=. Но указатели должны быть одного типа



---

* *Что такое константный указатель?*

Константный указатель — это указатель, значение которого не может быть изменено после инициализации. Для объявления константного указателя используется ключевое слово const между звёздочкой и именем указателя:

----
int * const ptr = &value1; 
----

---

* *Что такое указатель на константу?*

Указатель на константное значение — это неконстантный указатель, который указывает на неизменное значение. Для объявления указателя на константное значение, используется ключевое слово const перед типом данных:

----
const int *ptr = &value;
----

---

* *Что такое ссылка? В чем её отличие от указателя?*

Ссылка — это тип переменной в C++, который работает как псевдоним другого объекта или значения. C++ поддерживает три типа ссылок:

* Ссылки на неконстантные значения (обычно их называют просто «ссылки» или «неконстантные ссылки»), которые мы обсудим в этом уроке.

* Ссылки на константные значения (обычно их называют «константные ссылки»), которые мы обсудим в следующем уроке.

Ссылка (на неконстантное значение) объявляется с использованием амперсанда (&) между типом данных и именем ссылки:

Особенности ссылки:

* У ссылки нельзя взять адрес. Если применить оператор взятия адреса к ней, то будет выведен адрес переменной, на которую она ссылается

* Ссылка ведет себя почти также как константный указатель. Её нельзя изменять, складывать, вычитать

* Ссылки нельзя сравнивать

* Ссылка не может быть не проинициализирована.

Ссылка на переменную:

  int &ref = a; 


Ссылка — это тот же указатель, который неявно разыменовывается при доступе к значению, на которое он указывает

Поскольку ссылки должны быть инициализированы корректными объектами (они не могут быть нулевыми) и не могут быть изменены позже, то они, как правило, безопаснее указателей (так как риск разыменования нулевого указателя отпадает). Однако, они немного ограничены в функциональности, по сравнению с указателями.

Если определённое задание может быть решено с помощью как ссылок, так и указателей, то лучше использовать ссылки. Указатели следует использовать в ситуациях, только когда ссылки недостаточно эффективны (например, при динамическом выделении памяти).

---

* *Что такое регистр?*

Регистр - это определенный участок памяти внутри самого процессора, от 8-ми до 32-х бит длиной, который используется для промежуточного хранения информации, обрабатываемой процессором. Некоторые регистры содержат только определенную информацию.


Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

---

* *Что такое регистры общего назначения?*

Существуют регистры общего назначения и специальные регистры. Регистры общего назначения расположены внутри ядра микроконтроллера(сверхбыстрая память).

Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

---

* *Что такое регистры специального назначения?*

Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления процессором и периферийными устройствами.

---

* *Как можно установить бит в регистре специального назначения?*

Так как регистр специального назначения - это просто адресуемая ячейка памяти, то в коде это может мы можем обратиться к данным по этому адресу, разыменовывая указатель, указывающий на этот адрес.

Для того, чтобы настроить определенное периферийное устройство процессора, необходимо изменить значение поля соответствующем регистре.

Для более удобной работы с регистрами можно использовать С++ обертку. Эта обертка позволяет обращаться к регистрам в форме очень похоже с тем, как эти регистры описаны в документации.

Так, например, для запуска внешнего источника частоты, необходимо обратиться к регистру “CR” периферии “RCC”, полю HSEON и установить в нем значение Enable. Операция обращения к регистру выглядит следующим образом:

 int main()
 {
   RCC::CR::HSEON::Enable::Set() ;
 }

---

* *Объясните как вызывается функция.*

Функция должна быть объявлена в таком порядке, чтобы компилятор мог узнать как её вызвать. Объявление функции может выглядеть следующим образом:

 int MyFunction(int first, char * second);

Все что знает об этой функции компилятор, это то, что она принимает два параметра: целое и указатель на символ. И функция должна вернуть целое значение. Этого достаточно для компилятора, чтобы понять как вызвать эту функцию.

---

* *Что такое трансляция?*

Компилятор - программа выполняющая трансляцию исходного кода из предметно-ориентированногоязыка на машинно-ориентированный язык.

Структурно процесс трансляции с помощью компилятора показан на рисунке [Схема Трансляции]. После трансляции вы можете получить на выходе либо файлы библиотеки, которые впоследствии можно будет использовать в других проектах, либо объектные файлы.

.Схема  трансляции
image::Figure2.png[]

---

* *Что такое компоновка?*

В C + + , функция может компоноваться либо как С+ +, либо как С функция. Пример объявления функции с Си компоновкой:

 extern "C" {
   int F(int);
 }
 
Если вы хотите вызвать функции ассемблера из С++, то лучше объявить эту функцию, как имеющую тип компоновки Си

---

* *Как лучше организовывать структуру проекта и почему?*

При создании структуры проекта стоит соблюдать иерархическую структуру файлов, хранящихся на компьюетере. Это позволяет облегчить поиск требуемых компонентов. 
Структура должна иметь иерархическую модель. Все существующие подгруппы разбивают файлы на логические группы.

---

* *Что такое операторы?*

Оператор — это символ, который сообщает компилятору о необходимости выполнения некоторых математических или логических действий.

---

* *Какие арифметические операторы вы знаете?*


.Арифметические операторы
|=====================
|Операция | Оператор | Комментарий
|Присваивание       | =     | a = b
|Сложение           | +     | a + b
|Вычитание          | -     | a - b
|Унарный плюс       | +     | +a
|Унарный минус      | -     | -a
|Умножение          | *     | a * b
|Деление            | /     | a / b
|Остаток от деления | %     | a % b
|Инкремет  (пост и предфиксный)| ++      | &#43;&#43;a  и  a&#43;&#43;
|Декремент (пост и предфиксный)| - -     | --a и a--
|=====================

---

* *Какие логические операторы вы знаете?*

.Логические операторы
|=====================
|Операция | Оператор | Комментарий | Пример
|Логическое отрицание, НЕ   | !     | !a    |   !true => false
|Логическое умножение, И    | &&    | a && b| true && false => false
|Логическое сложение, ИЛИ   | &#124;&#124;  |   a &#124; &#124;  b  | true &#124; &#124;  false => true
|=====================

---

* *Какие побитовые операторы вы знаете?*

.Побитовые операторы
|=====================
|Операция | Оператор  | Комментарий | Пример
|Побитовая инверсия   | ~     | ~a  | unsigned char a = 0; ~a => 0xFF
|Побитовое И          | &     | a & b | unsigned char a = 1, b = 3; a & b => 1
|Побитовое ИЛИ        | &#124;   | a &#124; b | unsigned char a = 1, b = 3; a &#124; b => 3
|Побитовое исключающее ИЛИ  | ^   | a ^ b | unsigned char a = 1, b = 3; a ^ b => 2
|Побитовый сдвиг влево  | <<   | a << b | unsigned char a = 1, b = 3; a << b => 8
|Побитовый сдвиг вправо | >>   | a >> b | unsigned char a = 8, b = 3; a >> b => 1
|=====================

---

* *Приведите пример переопределения оператора*

[source, cpp]

----
class Integer // создание класса Integer
{
private: // модификатор доступа. доступ открыт самому классу.
    int value; // переменная типа int с названием value
public: //модификатор доступа. доступ открыт классам, производным от данного.
    Integer(int i): value(i)
    {}
    const Integer operator+(const Integer& rv) const {return (value + rv.value); //переопределение +
    }
};
----

---

* *Какие еще операторы вы знаете?*

Составное присваивание

Операторы работы с указателями и членами класса

Функторы, тернарные операции, sizeof(), запятая, приведение типа, new

---

* *Как сбросить бит с помощью битовых операторов?*

битовый И и отрицание:

 PORTB &= ~1; // сбрасывает 0-ой бит в PORT

---

* *Как установить бит с помощью битовых операторов?*

битовый ИЛИ:

 PORT | = 1; // устанавливает 0-ой бит в PORT

---

* *Как поменять значение бита с помощью битовых операторов?*

операция инвертирования:

 PORTB ^= 1; // меняет значение в 0-ой бите в PORT
 
---

* *Какой микроконтроллер на отладочной плате XNUCLE ST32F411?*

ARM® 32-bit Cortex™-M4

---

* *Какие блоки входят в состав микроконтроллера STM32F411?*

.Функциональные блоки микроконтроллера STM32F411
image::Figure3.png[]

---

* *В чем отличие ядра CortexM4 от CortexM3?*

Присутствие аппаратного модуля работы с плавающей точкой.

Присутствие набора инструкций DSP, SIMD, FP.

---

* *Назовите основные характеристики микроконтроллера STM32F411.*

|===
| 	32 разрядное ядро ARM Cortex-M4 | 	Блок работы с числами с плавающей точкой FPU
| 	512 кБайт памяти программ | 	128 кБайт ОЗУ
| Встроенный 12 битный 16 канальный АЦП |	DMA контроллер на 16 каналов
| USB 2.0 | 	3x USART
| 5 x SPI/I2S | 3x I2C
| SDIO интерфейс для карт SD/MMC/eMMC | Аппаратный подсчет контрольной суммы памяти программ CRC
| 6 - 16 разрядных и 2 - 32 разрядных Таймера |	1 - 16 битный для управления двигателями
| 2  сторожевых таймера |	1 системный таймер
| Работа на частотах до 100Мгц | 81 портов ввода вывода
| Питание от 1.7 до 3.6 Вольт | Потребление 100 мкА/Мгц
|===

---

* *Назовите дополнительные характеристики микроконтроллера STM32F411.*

Настраиваемые источники тактовой частоты

Настраиваемые на различные функции порты

Внутренний температурный сенсор

Таймеры с настраиваемым модулем ШИМ

DMA для работы с модулями (SPI, UART, ADC… )

12 разрядный ADC последовательного приближения

Часы реального времени

Системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ

---

* *Какие источники тактирования есть у микроконтроллера STM32F411*

4 основных источника:​

HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​

HSE (high-speed external) — внешний высокочастотный генератор.​

PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей, исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.

2 вторичных источника:​

LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​

LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц​

---

* *Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411.*

Алгоритм настройки частоты​Определить какие источники частоты нужны​

Например, PLL нужен для USB​

Включить нужный источник​

Используя Clock Control register (RCC::CR)​

Дождаться стабилизации источника ​

Используя соответствующие биты (..RDY) Clock Control register ​(RCC::CR)

Назначить нужный источник на системную частоту​

Используя Clock Configuration Register (RCC::CFGR)​

Дождаться пока источник не переключиться на системную частоту​

Используя Clock Configuration Register (RCC::CFGR)​

---

* *Что такое ФАПЧ?*

Фазовая автоподстройка частоты (ФАПЧ, англ. PLL ) — система автоматического регулирования, подстраивающая фазу управляемого генератора так, чтобы она была равна фазе опорного сигнала, либо отличалась на известную функцию от времени. 

---

* *Что делает следующий код?*

[source, cpp]

----
int main()
{
  int StudentUdacha = 10;
  int PrepodUdachca = 0 ;

  StudentUdacha =  StudentUdacha ^ PrepodUdachca ;
  PrepodUdachca =  StudentUdacha ^ PrepodUdachca ;
  StudentUdacha ^= PrepodUdachca ;
}
----



[source, cpp]

----
int main()
{
  int StudentUdacha = 10; // Присваивает переменной StudentUdacha значение 10
  int PrepodUdachca = 0 ; // Присваивает переменной PrepodUdachca значение 0

----


image::Figure4.png[]

поразрядное исключающее ИЛИ

----
  StudentUdacha =  StudentUdacha ^ PrepodUdachca ;
----

image::Figure5.png[]

поразрядное исключающее ИЛИ

----
  PrepodUdachca =  StudentUdacha ^ PrepodUdachca ;
----

image::Figure6.png[]

инвевртирует значение

----
  StudentUdacha ^= PrepodUdachca ;
}
----

image::Figure7.png[]

---

=== Задание 1

Адрес GPIOC 0x4002 0800 - 0x4002 0BFF

Cмещение регистра *GPIOС_MODER* относительно адреса *GPIOC* 

image::Figure8.png[]

Смещение регистра *GPIOС_ODR* относительно адреса *GPIOC* 

image::Figure9.png[]


Код получившейся программы:

[source, cpp]

----
#include "gpioaregisters.hpp"
#include "gpiocregisters.hpp" //
#include "rccregisters.hpp"

using namespace std;
void delay(uint32_t delay)
 {
   for (int i=0; i<delay; i++)
   {
   }
 }

int main() {
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  for(;;) {
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    GPIOC::ODR::ODR5::High::Set();
    GPIOC::ODR::ODR8::High::Set();
    GPIOC::ODR::ODR9::High::Set();
    delay (1'000'000);
    GPIOC::ODR::ODR5::Low::Set();
    GPIOC::ODR::ODR8::Low::Set();
    GPIOC::ODR::ODR9::Low::Set();
  }
  return 0 ;
}
----

Значение регистров GPIOС_MODER до запуска программы

image::Figure10.png[]

Значение регистров GPIOС_ODR до запуска программы

image::Figure11.png[]

Значение регистров GPIOС_MODER до задержки

image::Figure13.png[]

Значение регистров GPIOС_ODR до задержки

image::Figure12.png[]

Значение регистров GPIOС_MODER в конце программы

image::Figure14.png[]

Значение регистров GPIOС_ODR в конце программы

image::Figure15.png[]

---

=== Задание 2

Что лежит по адресам при включении портов и горящих диодах значение

image::Figure16.png[]

Код:

[source, cpp]

----
#include "gpioaregisters.hpp"
#include "gpiocregisters.hpp" //
#include "rccregisters.hpp"

using namespace std;
void delay(uint32_t delay)
 {
   for (int i=0; i<delay; i++)
   {
   }
 }

int main() {
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  for(;;) {
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    GPIOC::ODR::ODR5::High::Set();
    GPIOC::ODR::ODR8::High::Set();
    GPIOC::ODR::ODR9::High::Set();
    auto ptr = reinterpret_cast<volatile uint32_t *>(0x40020800) ;
    auto value = *ptr ;
    delay (1'000'000);
    GPIOC::ODR::ODR5::Low::Set();
    GPIOC::ODR::ODR8::Low::Set();
    GPIOC::ODR::ODR9::Low::Set();
  }
  return 0 ;
}
----

А вот проверку осуществить не получается :с

---

=== Задание 3

|=====================
| Номер варианта | Источник тактирования | Частота тактирования
|7|HSE| 4 Мгц
|=====================

* Определить какие источники частоты нужны​
  ** HSE​


* Включить нужный источник​
** Используя Clock Control register (RCC::CR)​

Регистр управления частотой
----
RCC::CR::HSEON::On::Set();
----

* Дождаться стабилизации источника ​
** Используя соответствующие биты (..RDY) Clock Control register ​(RCC::CR)

Регистр управления частотой. Контроль

----
 while ( !RCC::CR::HSERDY::Enable::IsSet( ) )
 {
 };
----


* Назначить нужный источник на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

Регистр конфигурации частоты. Выбор источника

----
RCC::CFGR::SW::Hse::Set();
----


* Дождаться пока источник не переключиться на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

----
while ( !RCC::CFGR::SWS::Hse::IsSet( ) )
    {  
    };
----

Настройка частоты тактирования

image::Figure17.png[]

Где посмотреть исходную частоту HSE для выбора делителя?

---

=== Задание 4

Код с лекции:

[source, cpp]

----

#include "gpioaregisters.hpp"
#include "gpiocregisters.hpp" //
#include "rccregisters.hpp"
#include "tim2registers.hpp"


extern "C" //внешний
{
  int __low_level_init(void)
  {
    RCC::CR::HSION::On::Set();
    while ( !RCC::CR::HSIRDY::Enable::IsSet( ) )
     {
       
     };
    
    RCC::CFGR::SW::Hsi::Set();
    while ( !RCC::CFGR::SWS::Hsi::IsSet( ) )
    {
      
    };
    
    RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
    RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
    GPIOA::MODER::MODER5::Output::Set() ;
    GPIOC::MODER::MODER5::Output::Set() ;
    GPIOC::MODER::MODER8::Output::Set() ;
    GPIOC::MODER::MODER9::Output::Set() ;
    GPIOC::MODER::MODER13::Input::Set() ;
    
    RCC::APB1ENR::TIM2EN::Enable::Set() ;
    TIM2::CR1::URS::OverFlow::Set();
    return 0;
  }
}

void Delay (std::uint32_t delay)

{
  TIM2::ARR::Write(16'000 * delay );
  TIM2::SR::UIF::NoUpdate::Set();
  TIM2::CNT::Write(0);
  TIM2::CR1::CEN::Enable::Set();
  while (TIM2::SR::UIF::NoUpdate::IsSet() )
  {
    
  }
  TIM2::CR1::CEN::Disable::Set();
}
               
int main()
{
  bool flag = false;
  for (; ;)
  {
 
    if(GPIOC::IDR::IDR13::Low::IsSet()) //kn vkl
    {
      while(GPIOC::IDR::IDR13::Low::IsSet())
      {
      } ;
      
      if(flag)
      {
        GPIOA::ODR::ODR5::High::Set ();
        GPIOC::ODR::ODR5::High::Set ();
        GPIOC::ODR::ODR8::High::Set ();
        GPIOC::ODR::ODR9::High::Set ();
        flag = false ;
      }
      else
      {
        GPIOA::ODR::ODR5::Low::Set ();
        GPIOC::ODR::ODR5::Low::Set ();
        GPIOC::ODR::ODR8::Low::Set ();
        GPIOC::ODR::ODR9::Low::Set ();
        flag = true ;
      }
    }
  }
}

----
